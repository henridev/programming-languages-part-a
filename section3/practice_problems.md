Extra Practice Problems
Contributed by Pavel Lepin and Charilaos Skiadas

Write a function \verb|compose_opt : ('b -> 'c option) -> ('a -> 'b option) -> 'a -> 'c option|compose_opt : (’b -> ’c option) -> (’a -> ’b option) -> ’a -> ’c option that composes two functions with "optional" values. If either function returns \verb|NONE|NONE, then the result is \verb|NONE|NONE.
Write a function \verb|do_until : ('a -> 'a) -> ('a -> bool) -> 'a -> 'a|do_until : (’a -> ’a) -> (’a -> bool) -> ’a -> ’a. \verb|do_until f p x|do_until f p x will apply \verb|f to x|f to x and \verb|f|f again to that result and so on until \verb|p x|p x is \verb|false|false. Example: \verb|do_until (fn x => x div 2) (fn x => x mod 2 <> 1)|do_until (fn x => x div 2) (fn x => x mod 2 <> 1) will evaluate to a function of type \verb|int->int|int->int that divides its argument by \verb|2|2 until it reaches an odd number. In effect, it will remove all factors of \verb|2|2 its argument.
Use \verb|do_until|do_until to implement factorial.
Use \verb|do_until|do_until to write a function \verb|fixed_point: (''a -> ''a) -> ''a -> ''a|fixed_point: (’’a -> ’’a) -> ’’a -> ’’a that given a function \verb|f|f and an initial value \verb|x|x applies \verb|f|f to \verb|x|x until \verb|f x = x|f x = x. (Notice the use of '' to indicate equality types.)
Write a function \verb|map2 : ('a -> 'b) -> 'a _ 'a -> 'b _ 'b|map2 : (’a -> ’b) -> ’a _ ’a -> ’b _ ’b that given a function that takes \verb|'a|’a values to \verb|'b|’b values and a pair of \verb|'a|’a values returns the corresponding pair of \verb|'b|’b values.
Write a function \verb|app_all : ('b -> 'c list) -> ('a -> 'b list) -> 'a -> 'c list|app_all : (’b -> ’c list) -> (’a -> ’b list) -> ’a -> ’c list, so that: \verb|app_all f g x|app_all f g x will apply \verb|f|f to every element of the list \verb|g x|g x and concatenate the results into a single list. For example, for \verb|fun f n = [n, 2 * n, 3 * n]|fun f n = [n, 2 * n, 3 * n], we have \verb|app_all f f 1 = [1, 2, 3, 2, 4, 6, 3, 6, 9]|app_all f f 1 = [1, 2, 3, 2, 4, 6, 3, 6, 9].
Implement \verb|List.foldr|List.foldr (see http://sml-family.org/Basis/list.html#SIG:LIST.foldr:VAL).
Write a function \verb|partition : ('a -> bool) -> 'a list -> 'a list _ 'a list|partition : (’a -> bool) -> ’a list -> ’a list _ ’a list where the first part of the result contains the second argument elements for which the first element evaluates to true and the second part of the result contains the other second argument elements. Traverse the second argument only once.
Write a function \verb|unfold : ('a -> ('b _ 'a) option) -> 'a -> 'b list|unfold : (’a -> (’b _ ’a) option) -> ’a -> ’b list that produces a list of \verb|'b|’b values given a "seed" of type \verb|'a|’a and a function that given a seed produces \verb|SOME|SOME of a pair of a \verb|'b|’b value and a new seed, or \verb|NONE|NONE if it is done seeding. For example, here is an elaborate way to count down from 5: \verb|unfold (fn n => if n = 0 then NONE else SOME(n, n-1)) 5 = [5, 4, 3, 2, 1]|unfold (fn n => if n = 0 then NONE else SOME(n, n-1)) 5 = [5, 4, 3, 2, 1].
Use \verb|unfold|unfold and $\verb|foldl|$\$ to implement factorial.
Implement \verb|map|map using \verb|List.foldr|List.foldr.
Implement \verb|filter|filter using \verb|List.foldr|List.foldr.
Implement \verb|foldl|foldl using \verb|foldr|foldr on functions. (This is challenging.)
Define a (polymorphic) type for binary trees where data is at internal nodes but not at leaves. Define \verb|map|map and \verb|fold|fold functions over such trees. You can define \verb|filter|filter as well where we interpret a "false" as meaning the entire subtree rooted at the node with data that produced false should be replaced with a leaf.
